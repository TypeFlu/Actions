#!/usr/bin/env python3

# A Python script to download and set up Android Command Line Tools on Linux and macOS.
# This script provides a beautiful and informative UI using the 'rich' library.
#
# Installation of dependencies:
# pip install rich requests beautifulsoup4

import os
import platform
import subprocess
import sys
import zipfile
from pathlib import Path
from time import sleep

import requests
from bs4 import BeautifulSoup
from rich.console import Console
from rich.panel import Panel
from rich.progress import (
    BarColumn,
    DownloadColumn,
    Progress,
    SpinnerColumn,
    TextColumn,
    TimeRemainingColumn,
    TransferSpeedColumn,
)
from rich.table import Table

# --- Configuration ---
# Use Path for modern, OS-agnostic path handling.
HOME_DIR = Path.home()
ANDROID_SDK_ROOT = HOME_DIR / "Android" / "sdk"
TMP_ZIP_FILE = Path("/tmp/android-cmdline-tools.zip")

# --- UI Setup using Rich ---
console = Console()

def print_success(message):
    """Prints a success message."""
    console.print(f"[bold green]✓[/bold green] {message}")

def print_info(message):
    """Prints an informational message."""
    console.print(f"[bold yellow]i[/bold yellow] {message}")

def print_error(message):
    """Prints an error message and exits."""
    console.print(f"[bold red]✗ ERROR:[/bold red] {message}")
    sys.exit(1)

def run_subprocess(command, text, success_message):
    """Runs a command in a subprocess with a spinner."""
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
    ) as progress:
        progress.add_task(description=text, total=None)
        # We pipe stdout and stderr to DEVNULL to keep the UI clean.
        # Errors are caught via the return code.
        result = subprocess.run(
            command, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
        )
    if result.returncode != 0:
        print_error(f"Failed to run '{' '.join(command)}'.")
    if success_message:
        print_success(success_message)

# --- Main Logic ---

def get_platform():
    """Detects the operating system."""
    system = platform.system()
    if system == "Linux":
        return "linux"
    elif system == "Darwin":
        return "mac"
    else:
        print_error(f"Unsupported operating system: {system}")

def find_download_url(os_platform):
    """Scrapes the Android Studio page to find the command-line tools download URL."""
    download_page_url = "https://developer.android.com/studio"
    print_info(f"Scraping {download_page_url} for the latest download link...")
    try:
        response = requests.get(download_page_url, timeout=10)
        response.raise_for_status()
        soup = BeautifulSoup(response.text, "html.parser")
        # The link is usually within a list item and contains the platform name in the URL.
        link = soup.find(
            "a", href=lambda href: href and f"commandlinetools-{os_platform}" in href
        )
        if not link or not link.get("href"):
            print_error("Could not find a download URL. The page structure might have changed.")
        return link["href"]
    except requests.RequestException as e:
        print_error(f"Failed to fetch the download page: {e}")

def download_tools(url):
    """Downloads the tools with a progress bar."""
    try:
        with requests.get(url, stream=True) as r:
            r.raise_for_status()
            total_size = int(r.headers.get("content-length", 0))
            with Progress(
                TextColumn("[bold blue]{task.description}", justify="right"),
                BarColumn(bar_width=None),
                "[progress.percentage]{task.percentage:>3.1f}%",
                "•",
                DownloadColumn(),
                "•",
                TransferSpeedColumn(),
                "•",
                TimeRemainingColumn(),
            ) as progress:
                task = progress.add_task("Downloading...", total=total_size)
                with open(TMP_ZIP_FILE, "wb") as f:
                    for chunk in r.iter_content(chunk_size=8192):
                        f.write(chunk)
                        progress.update(task, advance=len(chunk))
        print_success("Download complete.")
    except requests.RequestException as e:
        print_error(f"Download failed: {e}")
    except IOError as e:
        print_error(f"Could not write to file {TMP_ZIP_FILE}: {e}")

def extract_tools():
    """Extracts the downloaded zip file to the correct SDK location."""
    print_info(f"Setting up SDK directory at {ANDROID_SDK_ROOT}...")
    cmdline_tools_path = ANDROID_SDK_ROOT / "cmdline-tools"
    latest_tools_path = cmdline_tools_path / "latest"

    try:
        # Ensure the target directory exists
        cmdline_tools_path.mkdir(parents=True, exist_ok=True)

        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            transient=True,
        ) as progress:
            progress.add_task(description="Extracting files...", total=None)
            with zipfile.ZipFile(TMP_ZIP_FILE, "r") as zip_ref:
                # The zip extracts to a 'cmdline-tools' folder, so we extract and rename.
                zip_ref.extractall(cmdline_tools_path)
            
            # Rename the extracted folder to 'latest'
            extracted_dir = cmdline_tools_path / "cmdline-tools"
            if latest_tools_path.exists():
                # In case of re-running the script, remove the old 'latest'
                import shutil
                shutil.rmtree(latest_tools_path)
            extracted_dir.rename(latest_tools_path)

        # Clean up the downloaded zip file
        TMP_ZIP_FILE.unlink()
        print_success(f"Extracted tools to {latest_tools_path}")
    except (IOError, zipfile.BadZipFile) as e:
        print_error(f"Extraction failed: {e}")

def setup_environment_variables():
    """Configures environment variables in the user's shell profile."""
    print_info("Configuring environment variables...")
    
    # Determine the correct shell profile file
    shell = os.environ.get("SHELL", "")
    if "zsh" in shell:
        profile_file = HOME_DIR / ".zshrc"
    elif "bash" in shell:
        # On macOS, .bash_profile is often used for login shells
        if platform.system() == "Darwin" and (HOME_DIR / ".bash_profile").exists():
            profile_file = HOME_DIR / ".bash_profile"
        else:
            profile_file = HOME_DIR / ".bashrc"
    else:
        profile_file = HOME_DIR / ".profile"

    print_info(f"Updating profile: {profile_file}")
    
    # Ensure the profile file exists
    profile_file.touch()
    
    content = profile_file.read_text()
    
    # Lines to add to the profile
    lines_to_add = [
        '\n# Android SDK',
        f'export ANDROID_HOME="{ANDROID_SDK_ROOT}"',
        'export PATH=$PATH:$ANDROID_HOME/cmdline-tools/latest/bin',
        'export PATH=$PATH:$ANDROID_HOME/platform-tools',
        'export PATH=$PATH:$ANDROID_HOME/emulator',
    ]
    
    # Add lines if they are not already in the file
    added_lines = []
    with profile_file.open("a") as f:
        for line in lines_to_add:
            if line.split('=')[0] not in content: # Simple check to avoid duplicates
                f.write(line + '\n')
                added_lines.append(line)

    if added_lines:
        table = Table(title="Environment Variables Added", show_header=False)
        table.add_column("Configuration", style="cyan")
        table.add_row(f"Profile Updated: [bold]{profile_file}[/bold]")
        for line in added_lines:
            table.add_row(line)
        console.print(table)
        print_success("Environment variables configured.")
        print_info(f"Please run 'source {profile_file}' or restart your terminal to apply changes.")
    else:
        print_success("Environment variables already configured.")
        
    # Temporarily set variables for the rest of the script
    os.environ["ANDROID_HOME"] = str(ANDROID_SDK_ROOT)
    os.environ["PATH"] += f":{ANDROID_SDK_ROOT}/cmdline-tools/latest/bin:{ANDROID_SDK_ROOT}/platform-tools"

def install_sdk_packages():
    """Uses sdkmanager to install essential SDK packages."""
    print_info("Installing core SDK packages (this may take a while)...")
    sdkmanager = ANDROID_SDK_ROOT / "cmdline-tools" / "latest" / "bin" / "sdkmanager"

    # Suppress warnings from sdkmanager
    android_config_dir = HOME_DIR / ".android"
    android_config_dir.mkdir(exist_ok=True)
    (android_config_dir / "repositories.cfg").touch()

    # Accept licenses automatically
    run_subprocess(f"yes | {sdkmanager} --licenses", "Accepting SDK licenses...", "SDK licenses accepted.")
    
    # Install platform-tools, build-tools, and the latest platform
    run_subprocess(f"{sdkmanager} 'platform-tools'", "Installing platform-tools...", "Platform-tools installed.")
    
    # Get and install the latest build-tools
    try:
        list_output = subprocess.check_output([str(sdkmanager), "--list"], text=True)
        build_tools = [line.strip() for line in list_output.splitlines() if "build-tools;" in line]
        latest_build_tools = build_tools[-1].split(' ')[0]
        run_subprocess(f"{sdkmanager} '{latest_build_tools}'", f"Installing {latest_build_tools}...", "Latest build-tools installed.")
        
        # Get and install the latest platform
        platforms = [line.strip() for line in list_output.splitlines() if "platforms;android-" in line]
        latest_platform = platforms[-1].split(' ')[0]
        run_subprocess(f"{sdkmanager} '{latest_platform}'", f"Installing {latest_platform}...", "Latest platform installed.")

    except subprocess.CalledProcessError:
        print_error("Failed to list SDK packages. Check your connection or the SDK setup.")
    
    print_success("Core SDK packages installed.")

def verify_installation():
    """Checks if 'adb' is available in the path to verify the installation."""
    print_info("Verifying installation...")
    # Find adb using shutil.which which checks the PATH
    from shutil import which
    if which("adb"):
        version_output = subprocess.check_output(["adb", "version"], text=True).strip()
        print_success("'adb' is now in your path.")
        console.print(Panel(version_output, title="ADB Version", border_style="green"))
    else:
        print_error("Verification failed. 'adb' not found in PATH.")
        print_info("Try running 'source <your_profile_file>' or restarting your terminal.")

if __name__ == "__main__":
    console.print(Panel(
        "[bold cyan]Android Command-Line Tools Installer[/bold cyan]\nThis script will download and configure the Android SDK for you.",
        title="Welcome!",
        border_style="magenta"
    ))

    os_platform = get_platform()
    print_success(f"Detected Operating System: {os_platform.capitalize()}")

    download_url = find_download_url(os_platform)
    print_success(f"Found latest URL: {download_url}")
    
    download_tools(download_url)
    
    extract_tools()
    
    setup_environment_variables()
    
    install_sdk_packages()
    
    verify_installation()

    console.print(Panel(
        "[bold green]Setup is complete![/bold green]",
        title="Finished",
        border_style="green"
    ))
